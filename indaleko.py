import argparse
from typing import Any
import uuid
import json
import datetime

class Indaleko:
    '''This is the python implementation of the Indaleko data format.'''


    class Source:
        '''This schema defines the fields that are required as part of this
        metadata.  Additional (optional) metadata can be included.'''
        Schema = {
            "$schema": "https://json-schema.org/draft/2020-12/schema#",
            "$id": "https://activitycontext.work/schema/source.json",
            "title": "Data source schema",
            "description": "This schema describes information about the sources of metadata within the Indaleko system.",
            "type": "object",
            "properties": {
                "identifier": {
                    "description": "This is the UUID of the given source for this metadata.",
                    "type": "string",
                    "format": "uuid"
                },
                "version": {
                    "description": "This is the version of the source provider. Versioning allows evolution of the data generated by the source.",
                    "type": "string",
                },
            },
            "required": ["identifier", "version"]
        }


        def __init__(self, identifier : uuid.UUID, version : str, description : str) -> None:
            '''The identifier is a UUID, the version is a string, and the
            description is freeform text describing this source.'''
            ### Start with the public fields
            if not isinstance(identifier, uuid.UUID):
                raise TypeError('identifier must be a UUID')
            self.__identifier = identifier
            if type(version) is not str:
                raise TypeError('version must be a string')
            self.__version = version
            ## now we have internal fields that are not part of the stored data type
            if type(description) is not str and type(description) is not None:
                raise TypeError('description must be a string or None')
            self.__description = description
            self.__db_key = datetime.datetime.utcnow() # preserve date this was created

            def to_dict(self) -> dict:
                return {
                    'SourceIdentifier': str(self.__identifier),
                    'Version': self.__version,
                }

            def __str__(self) -> str:
                return json.dumps(self.to_dict())


        def set_db_key(self, db_key : str) -> 'Source':
            self.__db_key = db_key
            return self


        def get_db_key(self) -> str:
            return self.__db_key


        def to_dict(self) -> dict:
            return {
                'SourceIdentifier': str(self.__identifier),
                'Version': self.__version,
            }


        def get_source_identifer(self) -> uuid.UUID:
            return self.__identifier


        def get_version(self) -> str:
            return self.__version


        def get_description(self) -> str:
            return self.__description


        def to_dict(self) -> dict:
            return {
                'SourceIdentifier': str(self.__identifier),
                'Version': self.__version,
                'Description': self.__description,
                'DBKey': self.__db_key,
            }


        def __str__(self) -> str:
            return json.dumps(self.to_dict())


        def get_schema(self) -> str:
            return json.dumps(self.Schema, indent=4)



    class Record:

        Schema = {
            "$schema": "https://json-schema.org/draft/2020-12/schema#",
            "$id": "https://fsgeek.ca/indaleko/schema/record.json",
            "title": "Indaleko Record Schema",
            "description": "Schema for the JSON representation of an abstract record within Indaleko.",

            "type": "object",
            "properties": {
                "Source Identifier": { "$ref" : "schema/source.json" },
                "Timestamp": {
                    "type" : "string",
                    "description" : "The timestamp of when this record was created.",
                    "format" : "date-time",
                },
                "Attributes" : {
                    "type" : "object",
                    "description" : "The attributes extracted from the source data.",
                },
                "Data" : {
                    "type" : "string",
                    "description" : "The raw (uninterpreted) data from the source.",
                }
            },
            "required": ["Source Identifier", "Timestamp", "Attributes", "Data"]
        }


        def __init__(self, source : 'Indaleko.Source', attributes : dict, data : bytes):
            '''A record captures data gathered from an identified source,
            specific attributes extracted from the source data, and the original
            data.  The idea behind this is to permit sources to vary over time
            (versioning), with specific information converted to a common
            language (the attributes) and the original data preserved for future
            processing.  The fields can either be persistent (e.g., what is
            stored/loaded from the database) or transient (e.g., what is useful
            at runtime, such as for debugging.)'''
            if not isinstance(source, Indaleko.Source):
                raise TypeError('source must be a Source')
            self.__source = source
            if not isinstance(attributes, dict):
                raise TypeError('attributes must be a dict')
            self.__attributes = attributes
            if not isinstance(data, bytes):
                raise TypeError('data must be bytes')
            self.__data = data
            self.__timestamp = datetime.datetime.utcnow()


        def get_source(self) -> 'Source':
            return self.__source


        def get_attributes(self) -> dict:
            return self.__attributes


        def get_data(self) -> bytes:
            return self.__data

        def to_dict(self) -> dict:
            return {
                'Source': self.__source.to_dict(),
                'Attributes': self.__attributes,
                'Data': self.__data,
                'Timestamp': self.__timestamp,
            }

    class Machine:
        '''This class is intended to capture information about the specific
        machine where the data is being collected.  This becomes important when
        we have multiple machines collecting data, and we want to be able to
        identify information relative to the machine that collected it.  For
        example, a file URL isn't really useful by itself, since the file
        moniker does not properly identify how to retrieve the file. This isn't
        an issue with cloud services.'''

        def __init__(self, hostname : str, ip_address : str, mac_address : str, description : str) -> None:
            pass



    def __init__(self):
        pass


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--version', action='version', version='%(prog)s 1.0')
    args = parser.parse_args()
    print(args)

if __name__ == "__main__":
    main()
